using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using UnityProjectArchitect.Core;

namespace UnityProjectArchitect.Services.ConceptAware
{
    /// <summary>
    /// Generates work tickets based on game concepts rather than existing project analysis
    /// </summary>
    public class ConceptualWorkTicketsGenerator : BaseConceptAwareGenerator
    {
        public ConceptualWorkTicketsGenerator(string gameDescription) 
            : base(gameDescription, DocumentationSectionType.WorkTickets)
        {
        }

        public override async Task<string> GenerateContentAsync()
        {
            System.Console.WriteLine("[UnityProjectArchitect][AI DEBUG] ConceptualWorkTicketsGenerator: Starting content generation");
            try
            {
                // Get properly configured AI assistant
                IAIAssistant aiAssistant = _injectedAIAssistant;
                if (aiAssistant == null)
                {
                    #if UNITY_EDITOR
                    // Use Unity bridge's configured AI assistant
                    System.Console.WriteLine("[UnityProjectArchitect][AI DEBUG] Getting AI assistant from UnityServiceBridge");
                    aiAssistant = UnityProjectArchitect.Unity.UnityServiceBridge.GetAIAssistant();
                    #else
                    // For non-Unity builds, create a default AI assistant
                    System.Console.WriteLine("[UnityProjectArchitect][AI DEBUG] Creating default AI assistant");
                    aiAssistant = new UnityProjectArchitect.AI.Services.AIAssistant();
                    #endif
                }
                else
                {
                    System.Console.WriteLine("[UnityProjectArchitect][AI DEBUG] Using injected AI assistant");
                }
                if (aiAssistant?.IsConfigured == true)
                {
                    System.Console.WriteLine("[UnityProjectArchitect][AI DEBUG] AI assistant is configured. Building request...");
                    UnityProjectArchitect.Core.AIRequest request = new UnityProjectArchitect.Core.AIRequest
                    {
                        RequestType = UnityProjectArchitect.Core.AIRequestType.Generation,
                        Prompt = BuildWorkTicketsPrompt(),
                        ProjectContext = new UnityProjectArchitect.Core.ProjectData(),
                        Configuration = aiAssistant.GetDefaultConfiguration(UnityProjectArchitect.Core.AIProvider.Claude)
                    };
                    if (request.Parameters == null)
                        request.Parameters = new Dictionary<string, object>();
                    request.Parameters["GameDescription"] = gameDescription;
                    System.Console.WriteLine($"[UnityProjectArchitect][AI DEBUG] Sending AI request: Prompt length={request.Prompt.Length}, Config={request.Configuration.Provider}, MaxTokens={request.Configuration.MaxTokens}, Temp={request.Configuration.Temperature}");
                    var result = await aiAssistant.GenerateContentAsync(request);
                    if (result.Success && !string.IsNullOrEmpty(result.Content))
                    {
                        System.Console.WriteLine($"[UnityProjectArchitect][AI DEBUG] AI generation success: Content length={result.Content.Length} | Provider={result.Provider} | Time={result.ProcessingTime.TotalSeconds:F2}s");
                        StringBuilder aiContent = new StringBuilder();
                        aiContent.AppendLine("<!-- Generated by ConceptualWorkTicketsGenerator using Claude AI -->");
                        aiContent.AppendLine($"*Generated on {System.DateTime.Now:yyyy-MM-dd HH:mm:ss} UTC using Claude AI API*");
                        aiContent.AppendLine();
                        aiContent.AppendLine(result.Content);
                        aiContent.AppendLine();
                        aiContent.AppendLine("---");
                        aiContent.AppendLine("**Generation Metadata:**");
                        aiContent.AppendLine("- Generated by: ConceptualWorkTicketsGenerator with Claude AI");
                        aiContent.AppendLine($"- AI Provider: {result.Provider}");
                        aiContent.AppendLine($"- Processing Time: {result.ProcessingTime.TotalSeconds:F2} seconds");
                        aiContent.AppendLine($"- Generation Date: {System.DateTime.Now:yyyy-MM-dd HH:mm:ss}");
                        aiContent.AppendLine("---");
                        aiContent.AppendLine("<!-- End ConceptualWorkTicketsGenerator -->");
                        return aiContent.ToString();
                    }
                    else
                    {
                        System.Console.WriteLine($"[UnityProjectArchitect][AI DEBUG] AI generation failed or returned empty. Success={result.Success}, Error={result.ErrorMessage}");
                    }
                }
                else
                {
                    System.Console.WriteLine("[UnityProjectArchitect][AI DEBUG] AI assistant is not configured. Falling back to offline mode.");
                }
            }
            catch (Exception ex)
            {
                System.Console.WriteLine($"[UnityProjectArchitect][AI DEBUG] Exception during AI generation: {ex}");
            }
            System.Console.WriteLine("[UnityProjectArchitect][AI DEBUG] Using offline fallback for ConceptualWorkTicketsGenerator");
            // Fallback to offline generation
            StringBuilder content = new StringBuilder();

            // Add header and metadata (indicating offline generation)
            content.AppendLine("<!-- Generated by ConceptualWorkTicketsGenerator (Offline Mode) -->");
            content.Append(GetSectionHeader("Work Tickets"));
            content.AppendLine();
            content.Append(AddTimestamp());

            // Introduction
            content.Append(GenerateIntroduction());

            // Implementation Tickets
            content.Append(GenerateImplementationTickets());

            // Technical Infrastructure Tickets
            content.Append(GenerateTechnicalTickets());

            // Testing and Quality Assurance Tickets
            content.Append(GenerateTestingTickets());

            // Documentation and Deployment Tickets
            content.Append(GenerateDocumentationTickets());

            // Ticket Prioritization Matrix
            content.Append(GenerateTicketPrioritization());

            // Add generation metadata
            content.Append(AddGenerationMetadata());
            content.AppendLine("<!-- End ConceptualWorkTicketsGenerator -->");

            return await Task.FromResult(content.ToString());
        }

        private string BuildWorkTicketsPrompt()
        {
            return $@"Generate comprehensive development work tickets for a game project based on this concept:

{gameDescription}

Please create detailed work tickets organized into categories:
1. Implementation Tickets (core feature development)
2. Technical Infrastructure Tickets (systems and architecture)
3. Testing & QA Tickets (quality assurance tasks)
4. Documentation Tickets (guides and documentation)
5. Deployment Tickets (build and release tasks)

For each ticket include:
- Title and unique ID
- Clear description of the work
- Acceptance criteria
- Priority level (High/Medium/Low)
- Estimated effort/story points
- Dependencies (if any)
- Technical requirements

Use proper markdown formatting with headers and lists.
Focus on creating actionable, specific tickets that developers can work on.";
        }

        private string GenerateIntroduction()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(GetSectionHeader("Development Work Tickets Overview", 2));

            sb.AppendLine($"This document outlines the development work tickets for **{gameConcept.Title}**, ");
            sb.AppendLine($"organized by category and priority to guide the development process.");
            sb.AppendLine();

            sb.AppendLine("**Ticket Categories:**");
            sb.AppendLine("- **Implementation:** Core feature development tasks");
            sb.AppendLine("- **Technical Infrastructure:** Foundation systems and architecture");
            sb.AppendLine("- **Testing & QA:** Quality assurance and validation tasks");
            sb.AppendLine("- **Documentation:** Project documentation and guides");
            sb.AppendLine();

            return sb.ToString();
        }

        private string GenerateImplementationTickets()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(GetSectionHeader("Implementation Tickets", 2));

            List<WorkTicket> implementationTickets = GenerateImplementationTicketsForConcept();

            foreach (WorkTicket ticket in implementationTickets)
            {
                sb.Append(FormatTicket(ticket));
            }

            return sb.ToString();
        }

        private string GenerateTechnicalTickets()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(GetSectionHeader("Technical Infrastructure Tickets", 2));

            List<WorkTicket> technicalTickets = GenerateTechnicalInfrastructureTickets();

            foreach (WorkTicket ticket in technicalTickets)
            {
                sb.Append(FormatTicket(ticket));
            }

            return sb.ToString();
        }

        private string GenerateTestingTickets()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(GetSectionHeader("Testing & Quality Assurance Tickets", 2));

            List<WorkTicket> testingTickets = GenerateTestingAndQATickets();

            foreach (WorkTicket ticket in testingTickets)
            {
                sb.Append(FormatTicket(ticket));
            }

            return sb.ToString();
        }

        private string GenerateDocumentationTickets()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(GetSectionHeader("Documentation & Deployment Tickets", 2));

            List<WorkTicket> docTickets = GenerateDocumentationAndDeploymentTickets();

            foreach (WorkTicket ticket in docTickets)
            {
                sb.Append(FormatTicket(ticket));
            }

            return sb.ToString();
        }

        private string GenerateTicketPrioritization()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(GetSectionHeader("Ticket Prioritization Matrix", 2));

            Dictionary<string, List<string>> priorityMatrix = new Dictionary<string, List<string>>
            {
                ["Sprint 1 (MVP Foundation)"] = new List<string>
                {
                    "Project setup and architecture",
                    "Core player controls",
                    "Basic game mechanics",
                    "Essential UI framework",
                    "Scene management system"
                },
                ["Sprint 2 (Core Features)"] = new List<string>
                {
                    "Primary gameplay features",
                    "Game state management",
                    "Audio integration",
                    "Basic visual effects",
                    "Initial testing framework"
                },
                ["Sprint 3 (Enhanced Features)"] = new List<string>
                {
                    "Advanced gameplay mechanics",
                    "Enhanced UI/UX",
                    "Performance optimization",
                    "Additional game content",
                    "Platform-specific features"
                },
                ["Sprint 4 (Polish & Release)"] = new List<string>
                {
                    "Bug fixing and stability",
                    "Final performance tuning",
                    "Release preparation",
                    "Documentation completion",
                    "Marketing materials"
                }
            };

            foreach (KeyValuePair<string, List<string>> sprint in priorityMatrix)
            {
                sb.Append(GetSectionHeader(sprint.Key, 3));
                sb.Append(FormatList(sprint.Value));
            }

            return sb.ToString();
        }

        private List<WorkTicket> GenerateImplementationTicketsForConcept()
        {
            List<WorkTicket> tickets = new List<WorkTicket>();

            // Core game mechanics tickets
            tickets.Add(new WorkTicket
            {
                Id = "IMP-001",
                Title = "Implement Player Character Controller",
                Description = "Create responsive player movement and input handling system",
                Priority = TicketPriority.High,
                Complexity = TicketComplexity.Medium,
                EstimatedHours = 8,
                Dependencies = new List<string> { "Project setup complete" },
                AcceptanceCriteria = new List<string>
                {
                    "Player responds to input immediately",
                    "Movement feels smooth and natural",
                    "All input methods work correctly",
                    "Character constraints are properly enforced"
                },
                Skills = new List<string> { "Unity scripting", "Input systems", "Character controllers" }
            });

            // Add feature-specific tickets based on game concept
            foreach (string feature in gameConcept.CoreGameplayFeatures.Take(3))
            {
                tickets.Add(GenerateFeatureImplementationTicket(feature, tickets.Count + 1));
            }

            foreach (string feature in gameConcept.KeyFeatures.Take(3))
            {
                tickets.Add(GenerateFeatureImplementationTicket(feature, tickets.Count + 1));
            }

            // UI Implementation tickets
            tickets.Add(new WorkTicket
            {
                Id = $"IMP-{tickets.Count + 1:D3}",
                Title = "Implement Core User Interface",
                Description = "Create essential UI elements including menus, HUD, and settings",
                Priority = TicketPriority.High,
                Complexity = TicketComplexity.Medium,
                EstimatedHours = 12,
                Dependencies = new List<string> { "UI framework setup" },
                AcceptanceCriteria = new List<string>
                {
                    "Main menu is functional and navigable",
                    "In-game HUD displays necessary information",
                    "Settings menu allows configuration",
                    "UI is responsive and accessible"
                },
                Skills = new List<string> { "UI Toolkit", "UX design", "Unity scripting" }
            });

            return tickets;
        }

        private List<WorkTicket> GenerateTechnicalInfrastructureTickets()
        {
            List<WorkTicket> tickets = new List<WorkTicket>
            {
                new WorkTicket
                {
                    Id = "TECH-001",
                    Title = "Set Up Project Architecture",
                    Description = "Establish project structure, coding standards, and development workflow",
                    Priority = TicketPriority.High,
                    Complexity = TicketComplexity.Low,
                    EstimatedHours = 4,
                    Dependencies = new List<string>(),
                    AcceptanceCriteria = new List<string>
                    {
                        "Project follows Unity best practices",
                        "Folder structure is organized and logical",
                        "Coding standards are documented",
                        "Version control is properly configured"
                    },
                    Skills = new List<string> { "Unity project management", "Version control", "Architecture design" }
                },
                new WorkTicket
                {
                    Id = "TECH-002",
                    Title = "Implement Audio Management System",
                    Description = "Create centralized audio management for music, SFX, and voice",
                    Priority = TicketPriority.Medium,
                    Complexity = TicketComplexity.Medium,
                    EstimatedHours = 6,
                    Dependencies = new List<string> { "Project architecture setup" },
                    AcceptanceCriteria = new List<string>
                    {
                        "Audio can be played, paused, and stopped",
                        "Volume controls work for different audio types",
                        "Audio settings persist between sessions",
                        "Performance impact is minimal"
                    },
                    Skills = new List<string> { "Unity Audio", "C# scripting", "Performance optimization" }
                },
                new WorkTicket
                {
                    Id = "TECH-003",
                    Title = "Create Save/Load System",
                    Description = "Implement persistent data storage for player progress",
                    Priority = TicketPriority.High,
                    Complexity = TicketComplexity.High,
                    EstimatedHours = 10,
                    Dependencies = new List<string> { "Core gameplay mechanics" },
                    AcceptanceCriteria = new List<string>
                    {
                        "Game state can be saved and loaded reliably",
                        "Save data is protected from corruption",
                        "Multiple save slots are supported",
                        "Cross-platform compatibility is maintained"
                    },
                    Skills = new List<string> { "File I/O", "Data serialization", "Cross-platform development" }
                }
            };

            // Add technical feature tickets
            foreach (string feature in gameConcept.TechnicalFeatures)
            {
                tickets.Add(GenerateTechnicalFeatureTicket(feature, tickets.Count + 1));
            }

            return tickets;
        }

        private List<WorkTicket> GenerateTestingAndQATickets()
        {
            return new List<WorkTicket>
            {
                new WorkTicket
                {
                    Id = "QA-001",
                    Title = "Set Up Automated Testing Framework",
                    Description = "Establish unit testing and integration testing infrastructure",
                    Priority = TicketPriority.Medium,
                    Complexity = TicketComplexity.Medium,
                    EstimatedHours = 6,
                    Dependencies = new List<string> { "Project architecture setup" },
                    AcceptanceCriteria = new List<string>
                    {
                        "Unit testing framework is configured",
                        "Critical systems have test coverage",
                        "Tests can be run automatically",
                        "Test results are clearly reported"
                    },
                    Skills = new List<string> { "Unit testing", "Test automation", "Unity Test Runner" }
                },
                new WorkTicket
                {
                    Id = "QA-002",
                    Title = "Performance Testing and Optimization",
                    Description = "Conduct performance testing and optimize for target platforms",
                    Priority = TicketPriority.Medium,
                    Complexity = TicketComplexity.High,
                    EstimatedHours = 12,
                    Dependencies = new List<string> { "Core features implemented" },
                    AcceptanceCriteria = new List<string>
                    {
                        "Performance meets target framerates",
                        "Memory usage is within acceptable limits",
                        "Loading times are reasonable",
                        "No performance regressions introduced"
                    },
                    Skills = new List<string> { "Performance profiling", "Optimization techniques", "Unity Profiler" }
                },
                new WorkTicket
                {
                    Id = "QA-003",
                    Title = "Cross-Platform Testing",
                    Description = "Test game functionality across all target platforms",
                    Priority = TicketPriority.High,
                    Complexity = TicketComplexity.Medium,
                    EstimatedHours = 8,
                    Dependencies = new List<string> { "Platform builds available" },
                    AcceptanceCriteria = new List<string>
                    {
                        "Game builds and runs on all target platforms",
                        "Platform-specific features work correctly",
                        "Controls adapt appropriately to platform",
                        "Performance is acceptable on minimum specs"
                    },
                    Skills = new List<string> { "Cross-platform development", "Platform testing", "Unity build systems" }
                }
            };
        }

        private List<WorkTicket> GenerateDocumentationAndDeploymentTickets()
        {
            return new List<WorkTicket>
            {
                new WorkTicket
                {
                    Id = "DOC-001",
                    Title = "Create Technical Documentation",
                    Description = "Document code architecture, APIs, and development processes",
                    Priority = TicketPriority.Low,
                    Complexity = TicketComplexity.Low,
                    EstimatedHours = 8,
                    Dependencies = new List<string> { "Core systems implemented" },
                    AcceptanceCriteria = new List<string>
                    {
                        "Code architecture is documented",
                        "API documentation is complete",
                        "Development workflow is explained",
                        "Troubleshooting guides are available"
                    },
                    Skills = new List<string> { "Technical writing", "Documentation tools", "Software architecture" }
                },
                new WorkTicket
                {
                    Id = "DOC-002",
                    Title = "Prepare Release Package",
                    Description = "Create final build and prepare for distribution",
                    Priority = TicketPriority.High,
                    Complexity = TicketComplexity.Medium,
                    EstimatedHours = 6,
                    Dependencies = new List<string> { "All features complete", "Testing passed" },
                    AcceptanceCriteria = new List<string>
                    {
                        "Final builds are created for all platforms",
                        "Release notes are prepared",
                        "Distribution packages are ready",
                        "Store listings are completed"
                    },
                    Skills = new List<string> { "Build automation", "Release management", "Platform publishing" }
                }
            };
        }

        private WorkTicket GenerateFeatureImplementationTicket(string feature, int ticketNumber)
        {
            return new WorkTicket
            {
                Id = $"IMP-{ticketNumber:D3}",
                Title = $"Implement {feature}",
                Description = $"Develop and integrate the {feature.ToLower()} feature into the game",
                Priority = DetermineFeaturePriority(feature),
                Complexity = DetermineFeatureComplexity(feature),
                EstimatedHours = EstimateFeatureHours(feature),
                Dependencies = new List<string> { "Core systems setup" },
                AcceptanceCriteria = new List<string>
                {
                    $"{feature} is fully functional",
                    "Feature integrates well with existing systems",
                    "Performance impact is acceptable",
                    "User experience is intuitive"
                },
                Skills = DetermineRequiredSkills(feature)
            };
        }

        private WorkTicket GenerateTechnicalFeatureTicket(string feature, int ticketNumber)
        {
            return new WorkTicket
            {
                Id = $"TECH-{ticketNumber:D3}",
                Title = $"Implement {feature}",
                Description = $"Set up and configure {feature.ToLower()} infrastructure",
                Priority = TicketPriority.Medium,
                Complexity = TicketComplexity.High,
                EstimatedHours = 12,
                Dependencies = new List<string> { "Core architecture complete" },
                AcceptanceCriteria = new List<string>
                {
                    $"{feature} infrastructure is operational",
                    "Integration with game systems is seamless",
                    "Performance requirements are met",
                    "Scalability considerations are addressed"
                },
                Skills = new List<string> { "Advanced Unity features", "System integration", "Performance optimization" }
            };
        }

        private string FormatTicket(WorkTicket ticket)
        {
            StringBuilder sb = new StringBuilder();
            
            sb.Append(GetSectionHeader($"[{ticket.Id}] {ticket.Title}", 3));
            sb.AppendLine($"**Description:** {ticket.Description}");
            sb.AppendLine();
            sb.AppendLine($"**Priority:** {ticket.Priority} | **Complexity:** {ticket.Complexity} | **Estimated Hours:** {ticket.EstimatedHours}");
            sb.AppendLine();
            
            if (ticket.Dependencies.Any())
            {
                sb.AppendLine("**Dependencies:**");
                sb.Append(FormatList(ticket.Dependencies));
            }
            
            sb.AppendLine("**Acceptance Criteria:**");
            sb.Append(FormatList(ticket.AcceptanceCriteria));
            
            if (ticket.Skills.Any())
            {
                sb.AppendLine("**Required Skills:**");
                sb.Append(FormatList(ticket.Skills));
            }
            
            sb.AppendLine();
            return sb.ToString();
        }

        private TicketPriority DetermineFeaturePriority(string feature)
        {
            string lowerFeature = feature.ToLower();
            
            if (lowerFeature.Contains("core") || lowerFeature.Contains("basic") || lowerFeature.Contains("essential"))
                return TicketPriority.High;
            if (lowerFeature.Contains("advanced") || lowerFeature.Contains("optional"))
                return TicketPriority.Low;
            
            return TicketPriority.Medium;
        }

        private TicketComplexity DetermineFeatureComplexity(string feature)
        {
            string lowerFeature = feature.ToLower();
            
            if (lowerFeature.Contains("ai") || lowerFeature.Contains("multiplayer") || lowerFeature.Contains("procedural"))
                return TicketComplexity.High;
            if (lowerFeature.Contains("ui") || lowerFeature.Contains("menu") || lowerFeature.Contains("simple"))
                return TicketComplexity.Low;
            
            return TicketComplexity.Medium;
        }

        private int EstimateFeatureHours(string feature)
        {
            TicketComplexity complexity = DetermineFeatureComplexity(feature);
            
            return complexity switch
            {
                TicketComplexity.Low => 4,
                TicketComplexity.Medium => 8,
                TicketComplexity.High => 16,
                _ => 8
            };
        }

        private List<string> DetermineRequiredSkills(string feature)
        {
            List<string> skills = new List<string> { "Unity scripting", "C# programming" };
            
            string lowerFeature = feature.ToLower();
            
            if (lowerFeature.Contains("ui") || lowerFeature.Contains("menu"))
                skills.Add("UI Toolkit");
            if (lowerFeature.Contains("animation"))
                skills.Add("Unity Animation");
            if (lowerFeature.Contains("physics"))
                skills.Add("Unity Physics");
            if (lowerFeature.Contains("audio"))
                skills.Add("Unity Audio");
            if (lowerFeature.Contains("ai"))
                skills.Add("AI programming");
            if (lowerFeature.Contains("multiplayer") || lowerFeature.Contains("network"))
                skills.Add("Networking");
            
            return skills;
        }
    }

    public class WorkTicket
    {
        public string Id { get; set; } = "";
        public string Title { get; set; } = "";
        public string Description { get; set; } = "";
        public TicketPriority Priority { get; set; } = TicketPriority.Medium;
        public TicketComplexity Complexity { get; set; } = TicketComplexity.Medium;
        public int EstimatedHours { get; set; } = 0;
        public List<string> Dependencies { get; set; } = new List<string>();
        public List<string> AcceptanceCriteria { get; set; } = new List<string>();
        public List<string> Skills { get; set; } = new List<string>();
    }

    public enum TicketPriority
    {
        Low,
        Medium,
        High,
        Critical
    }

    public enum TicketComplexity
    {
        Low,
        Medium,
        High
    }
}
