using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using UnityProjectArchitect.Core;
using UnityProjectArchitect.AI;

namespace UnityProjectArchitect.Services.ConceptAware
{
    /// <summary>
    /// Generates product descriptions based on game concepts rather than existing project analysis
    /// </summary>
    public class ConceptualProductDescriptionGenerator : BaseConceptAwareGenerator
    {
        public ConceptualProductDescriptionGenerator(string gameDescription) 
            : base(gameDescription, DocumentationSectionType.GeneralProductDescription)
        {
        }

        public override async Task<string> GenerateContentAsync()
        {
            // Try AI generation first if available
            try
            {
                // Get properly configured AI assistant
                IAIAssistant aiAssistant = null;
                #if UNITY_EDITOR
                // Use Unity bridge's configured AI assistant
                aiAssistant = UnityProjectArchitect.Unity.UnityServiceBridge.GetAIAssistant();
                #else
                // For non-Unity builds, create a default AI assistant
                aiAssistant = new UnityProjectArchitect.AI.Services.AIAssistant();
                #endif
                
                if (aiAssistant?.IsConfigured == true)
                {
                    // Create AI request for conceptual product description
                    var request = new UnityProjectArchitect.Core.AIRequest
                    {
                        RequestType = UnityProjectArchitect.Core.AIRequestType.Generation,
                        Prompt = BuildConceptualProductDescriptionPrompt(),
                        SectionType = sectionType,
                        Configuration = new UnityProjectArchitect.Core.AIConfiguration
                        {
                            Provider = UnityProjectArchitect.Core.AIProvider.Claude,
                            MaxTokens = 4000,
                            Temperature = 0.7f
                        }
                    };

                    // Add game description as parameter
                    if (request.Parameters == null)
                        request.Parameters = new Dictionary<string, object>();
                    request.Parameters["GameDescription"] = gameDescription;

                    UnityProjectArchitect.Core.AIOperationResult result = await aiAssistant.GenerateContentAsync(request);
                    if (result.Success && !string.IsNullOrEmpty(result.Content))
                    {
                        // Add AI generation metadata
                        StringBuilder aiContent = new StringBuilder();
                        aiContent.AppendLine("<!-- Generated by ConceptualProductDescriptionGenerator using Claude AI -->");
                        aiContent.AppendLine($"*Generated on {System.DateTime.Now:yyyy-MM-dd HH:mm:ss} UTC using Claude AI API*");
                        aiContent.AppendLine();
                        aiContent.AppendLine(result.Content);
                        aiContent.AppendLine();
                        aiContent.AppendLine("---");
                        aiContent.AppendLine("**Generation Metadata:**");
                        aiContent.AppendLine("- Generated by: ConceptualProductDescriptionGenerator with Claude AI");
                        aiContent.AppendLine($"- AI Provider: {result.Provider}");
                        aiContent.AppendLine($"- Processing Time: {result.ProcessingTime.TotalSeconds:F2} seconds");
                        aiContent.AppendLine($"- Generation Date: {System.DateTime.Now:yyyy-MM-dd HH:mm:ss}");
                        aiContent.AppendLine("---");
                        aiContent.AppendLine("<!-- End ConceptualProductDescriptionGenerator -->");
                        
                        return aiContent.ToString();
                    }
                }
            }
            catch (Exception ex)
            {
                // Log the error but continue with offline generation
                System.Diagnostics.Debug.WriteLine($"AI generation failed, using offline fallback: {ex.Message}");
            }

            // Fallback to offline generation
            StringBuilder content = new StringBuilder();

            // Add header and metadata
            content.AppendLine("<!-- Generated by ConceptualProductDescriptionGenerator (Offline Mode) -->");
            content.Append(GetSectionHeader("General Product Description"));
            content.AppendLine();
            content.Append(AddTimestamp());

            // Game Overview Section
            content.Append(GenerateGameOverview());

            // Core Concept Section
            content.Append(GenerateCoreConcept());

            // Gameplay Features Section
            content.Append(GenerateGameplayFeatures());

            // Technical Requirements Section
            content.Append(GenerateTechnicalRequirements());

            // Target Audience & Market Section
            content.Append(GenerateTargetAudience());

            // Development Scope Section
            content.Append(GenerateDevelopmentScope());

            // Key Success Factors
            content.Append(GenerateSuccessFactors());

            // Add generation metadata
            content.Append(AddGenerationMetadata());
            content.AppendLine("<!-- End ConceptualProductDescriptionGenerator -->");

            return await Task.FromResult(content.ToString());
        }

        private string GenerateGameOverview()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(GetSectionHeader("Game Overview", 2));

            Dictionary<string, string> overview = new Dictionary<string, string>
            {
                ["Game Title"] = gameConcept.Title,
                ["Genre"] = GetGenreDescription(gameConcept.GameGenre),
                ["Platform"] = !string.IsNullOrEmpty(gameConcept.Platform) ? gameConcept.Platform : "Multi-Platform",
                ["Project Type"] = GetProjectTypeDescription(gameConcept.GameType),
                ["Art Style"] = !string.IsNullOrEmpty(gameConcept.ArtStyle) ? gameConcept.ArtStyle : "To be determined",
                ["Target Audience"] = !string.IsNullOrEmpty(gameConcept.TargetAudience) ? gameConcept.TargetAudience : "General gaming audience"
            };

            if (!string.IsNullOrEmpty(gameConcept.DevelopmentTime))
            {
                overview["Development Timeline"] = gameConcept.DevelopmentTime;
            }

            sb.Append(FormatTable(overview, "Property", "Details"));

            return sb.ToString();
        }

        private string GenerateCoreConcept()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(GetSectionHeader("Core Game Concept", 2));

            if (!string.IsNullOrEmpty(gameConcept.CoreDescription))
            {
                sb.AppendLine($"**Vision Statement:**");
                sb.AppendLine(gameConcept.CoreDescription);
                sb.AppendLine();
            }

            if (gameConcept.CoreGameplayFeatures.Any())
            {
                sb.AppendLine("**Core Gameplay Elements:**");
                sb.Append(FormatList(gameConcept.CoreGameplayFeatures));
            }

            if (gameConcept.KeyFeatures.Any())
            {
                sb.AppendLine("**Key Game Features:**");
                sb.Append(FormatList(gameConcept.KeyFeatures));
            }

            return sb.ToString();
        }

        private string GenerateGameplayFeatures()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(GetSectionHeader("Gameplay Features & Mechanics", 2));

            // Generate feature categories based on genre
            List<string> expectedFeatures = GenerateExpectedFeatures();
            
            sb.AppendLine("**Core Mechanics:**");
            if (gameConcept.CoreGameplayFeatures.Any())
            {
                sb.Append(FormatList(gameConcept.CoreGameplayFeatures));
            }
            else
            {
                sb.Append(FormatList(expectedFeatures.Take(3)));
            }

            sb.AppendLine("**Advanced Features:**");
            if (gameConcept.KeyFeatures.Any())
            {
                sb.Append(FormatList(gameConcept.KeyFeatures));
            }
            else
            {
                sb.Append(FormatList(expectedFeatures.Skip(3).Take(3)));
            }

            if (gameConcept.TechnicalFeatures.Any())
            {
                sb.AppendLine("**Technical Features:**");
                sb.Append(FormatList(gameConcept.TechnicalFeatures));
            }

            return sb.ToString();
        }

        private string GenerateTechnicalRequirements()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(GetSectionHeader("Technical Requirements", 2));

            Dictionary<string, string> requirements = GenerateTechnicalSpecs();
            sb.Append(FormatTable(requirements, "Component", "Specification"));

            sb.AppendLine("**Recommended Unity Features:**");
            List<string> unityFeatures = GenerateUnityFeatureRecommendations();
            sb.Append(FormatList(unityFeatures));

            return sb.ToString();
        }

        private string GenerateTargetAudience()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(GetSectionHeader("Target Audience & Market Position", 2));

            if (!string.IsNullOrEmpty(gameConcept.TargetAudience))
            {
                sb.AppendLine($"**Primary Audience:** {gameConcept.TargetAudience}");
                sb.AppendLine();
            }

            sb.AppendLine("**Market Position:**");
            List<string> marketPosition = GenerateMarketPosition();
            sb.Append(FormatList(marketPosition));

            sb.AppendLine("**Monetization Opportunities:**");
            List<string> monetization = GenerateMonetizationStrategies();
            sb.Append(FormatList(monetization));

            return sb.ToString();
        }

        private string GenerateDevelopmentScope()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(GetSectionHeader("Development Scope & Estimates", 2));

            Dictionary<string, string> scope = GenerateDevelopmentEstimates();
            sb.Append(FormatTable(scope, "Phase", "Estimate"));

            sb.AppendLine("**Key Development Milestones:**");
            List<string> milestones = GenerateDevelopmentMilestones();
            sb.Append(FormatList(milestones, true));

            return sb.ToString();
        }

        private string GenerateSuccessFactors()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(GetSectionHeader("Key Success Factors", 2));

            List<string> successFactors = GenerateKeySuccessFactors();
            sb.Append(FormatList(successFactors));

            sb.AppendLine("**Risk Mitigation:**");
            List<string> risks = GenerateRiskMitigation();
            sb.Append(FormatList(risks));

            return sb.ToString();
        }

        private List<string> GenerateExpectedFeatures()
        {
            List<string> features = new List<string>();

            switch (gameConcept.GameGenre)
            {
                case GameGenre.RPG:
                    features.AddRange(new[] {
                        "Character progression and skill trees",
                        "Inventory and equipment management",
                        "Quest and dialogue systems",
                        "Combat mechanics with stats",
                        "World exploration and discovery",
                        "Crafting and item creation"
                    });
                    break;

                case GameGenre.Action:
                    features.AddRange(new[] {
                        "Fast-paced combat mechanics",
                        "Responsive character controls",
                        "Enemy AI and behavior systems",
                        "Power-ups and abilities",
                        "Level progression and challenges",
                        "Scoring and achievement systems"
                    });
                    break;

                case GameGenre.Puzzle:
                    features.AddRange(new[] {
                        "Logic-based puzzle mechanics",
                        "Progressive difficulty scaling",
                        "Hint and help systems",
                        "Level editor functionality",
                        "Achievement and progress tracking",
                        "Multiple solution pathways"
                    });
                    break;

                default:
                    features.AddRange(new[] {
                        "Core gameplay loop",
                        "User interface systems",
                        "Audio and visual feedback",
                        "Progress saving and loading",
                        "Settings and customization",
                        "Performance optimization"
                    });
                    break;
            }

            return features;
        }

        private Dictionary<string, string> GenerateTechnicalSpecs()
        {
            Dictionary<string, string> specs = new Dictionary<string, string>
            {
                ["Unity Version"] = "2023.3 LTS or newer",
                ["Rendering Pipeline"] = gameConcept.GameType == ProjectType.Game3D ? "Universal Render Pipeline (URP)" : "Built-in Render Pipeline",
                ["Platform Target"] = !string.IsNullOrEmpty(gameConcept.Platform) ? gameConcept.Platform : "PC/Console/Mobile",
                ["Minimum RAM"] = gameConcept.GameType == ProjectType.Game3D ? "8 GB" : "4 GB",
                ["Storage Space"] = EstimateStorageRequirement(),
                ["Network Requirements"] = gameConcept.TechnicalFeatures.Any(f => f.Contains("Multiplayer")) ? "Broadband Internet" : "None"
            };

            return specs;
        }

        private List<string> GenerateUnityFeatureRecommendations()
        {
            List<string> features = new List<string>
            {
                "UI Toolkit for modern user interfaces",
                "Addressables for efficient asset management",
                "Unity Analytics for player insights"
            };

            if (gameConcept.GameType == ProjectType.Game3D)
            {
                features.Add("ProBuilder for level prototyping");
                features.Add("Cinemachine for camera management");
                features.Add("Timeline for cutscenes and animations");
            }

            if (gameConcept.TechnicalFeatures.Any(f => f.Contains("Multiplayer")))
            {
                features.Add("Netcode for GameObjects for multiplayer");
                features.Add("Unity Relay and Lobby services");
            }

            if (gameConcept.GameType == ProjectType.Mobile)
            {
                features.Add("Mobile optimization packages");
                features.Add("Unity Ads for monetization");
            }

            return features;
        }

        private List<string> GenerateMarketPosition()
        {
            List<string> position = new List<string>
            {
                $"Targets the {gameConcept.GameGenre.ToString().ToLower()} game market",
                $"Designed for {gameConcept.GameType.ToString().Replace("Game", "").ToLower()} gaming platforms"
            };

            if (!string.IsNullOrEmpty(gameConcept.TargetAudience))
            {
                position.Add($"Appeals to {gameConcept.TargetAudience.ToLower()}");
            }

            position.Add("Emphasizes engaging gameplay over complex mechanics");
            position.Add("Focuses on accessibility and user-friendly design");

            return position;
        }

        private List<string> GenerateMonetizationStrategies()
        {
            List<string> strategies = new List<string>();

            if (gameConcept.GameType == ProjectType.Mobile)
            {
                strategies.AddRange(new[] {
                    "Freemium model with optional premium content",
                    "In-app purchases for cosmetics and convenience",
                    "Rewarded video ads for bonus content",
                    "Battle pass or subscription options"
                });
            }
            else
            {
                strategies.AddRange(new[] {
                    "Premium purchase model",
                    "Downloadable content (DLC) expansions",
                    "Cosmetic item marketplace",
                    "Season pass for ongoing content"
                });
            }

            return strategies;
        }

        private Dictionary<string, string> GenerateDevelopmentEstimates()
        {
            Dictionary<string, string> estimates = new Dictionary<string, string>();

            if (!string.IsNullOrEmpty(gameConcept.DevelopmentTime))
            {
                estimates["Total Development"] = gameConcept.DevelopmentTime;
            }
            else
            {
                estimates["Total Development"] = EstimateDevelopmentTime();
            }

            estimates["Pre-production"] = "2-4 weeks";
            estimates["Production"] = "70% of total time";
            estimates["Polish & Testing"] = "20% of total time";
            estimates["Post-launch Support"] = "Ongoing";

            return estimates;
        }

        private List<string> GenerateDevelopmentMilestones()
        {
            return new List<string>
            {
                "Concept validation and design document completion",
                "Core gameplay mechanics implementation",
                "Art style and asset pipeline establishment",
                "Alpha build with basic features",
                "Beta testing and user feedback integration",
                "Performance optimization and bug fixing",
                "Platform-specific adaptation and testing",
                "Launch preparation and marketing"
            };
        }

        private List<string> GenerateKeySuccessFactors()
        {
            return new List<string>
            {
                "Strong core gameplay loop that keeps players engaged",
                "Clear and intuitive user interface design",
                "Consistent art style and visual polish",
                "Responsive and accessible controls",
                "Regular content updates and community engagement",
                "Effective marketing and player acquisition strategy",
                "Post-launch support and bug fixing",
                "Platform-specific optimization and features"
            };
        }

        private List<string> GenerateRiskMitigation()
        {
            return new List<string>
            {
                "Regular playtesting to validate gameplay assumptions",
                "Modular development approach for flexible scope adjustment",
                "Early platform testing to identify technical constraints",
                "Community building and feedback collection",
                "Contingency planning for scope reduction if needed",
                "Regular team check-ins and milestone reviews"
            };
        }

        private string EstimateStorageRequirement()
        {
            return gameConcept.GameType switch
            {
                ProjectType.Game3D => "2-8 GB",
                ProjectType.VR => "4-12 GB",
                ProjectType.Mobile => "100-500 MB",
                ProjectType.Game2D => "500 MB - 2 GB",
                _ => "1-4 GB"
            };
        }

        private string EstimateDevelopmentTime()
        {
            return gameConcept.GameType switch
            {
                ProjectType.Mobile => "6-12 months",
                ProjectType.Game2D => "8-18 months",
                ProjectType.Game3D => "12-24 months",
                ProjectType.VR => "18-30 months",
                _ => "12-18 months"
            };
        }

        private string GetGenreDescription(GameGenre genre)
        {
            return genre switch
            {
                GameGenre.Action => "Fast-paced action game with dynamic gameplay",
                GameGenre.Adventure => "Story-driven adventure with exploration elements",
                GameGenre.RPG => "Role-playing game with character progression",
                GameGenre.Strategy => "Strategic gameplay requiring planning and tactics",
                GameGenre.Puzzle => "Logic-based puzzle solving experience",
                GameGenre.Platformer => "Platform-based movement and jumping mechanics",
                GameGenre.Racing => "Racing and vehicle-based competition",
                GameGenre.Simulation => "Realistic simulation of real-world activities",
                GameGenre.FPS => "First-person perspective action shooting",
                _ => "Engaging interactive entertainment experience"
            };
        }

        private string GetProjectTypeDescription(ProjectType projectType)
        {
            return projectType switch
            {
                ProjectType.Game2D => "2D Game Project - Sprite-based gameplay with 2D mechanics",
                ProjectType.Game3D => "3D Game Project - Full 3D environment with spatial gameplay",
                ProjectType.VR => "Virtual Reality Project - Immersive VR experience",
                ProjectType.AR => "Augmented Reality Project - AR application with real-world integration",
                ProjectType.Mobile => "Mobile Game Project - Optimized for mobile platforms",
                _ => "Interactive Entertainment Project - Flexible game development approach"
            };
        }

        private string BuildConceptualProductDescriptionPrompt()
        {
            return $@"Generate a comprehensive General Product Description for a game concept. 

Based on the game description provided, create a professional product description that includes:

1. **Game Overview**: Title, genre, platform, and high-level concept
2. **Core Concept**: The fundamental game idea and what makes it unique
3. **Key Gameplay Features**: Main mechanics and systems players will interact with
4. **Technical Requirements**: Development scope, target platforms, and technical considerations
5. **Target Audience & Market**: Who will play this game and market positioning
6. **Development Scope**: Timeline, team requirements, and project scale
7. **Key Success Factors**: What elements are critical for the game's success

Use the actual game concept provided in the context. Format the output as professional markdown with clear headers and sections. Make it sound professional and engaging, suitable for stakeholders, publishers, or development teams.

Focus on translating the game concept into a structured product description that captures both the creative vision and practical development considerations.";
        }
    }
}
