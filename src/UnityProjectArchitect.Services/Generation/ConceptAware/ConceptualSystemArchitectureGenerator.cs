using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using UnityProjectArchitect.Core;

namespace UnityProjectArchitect.Services.ConceptAware
{
    /// <summary>
    /// Generates system architecture documentation based on game concepts rather than existing project analysis
    /// </summary>
    public class ConceptualSystemArchitectureGenerator : BaseConceptAwareGenerator
    {
        public ConceptualSystemArchitectureGenerator(string gameDescription) 
            : base(gameDescription, DocumentationSectionType.SystemArchitecture)
        {
        }

        public override async Task<string> GenerateContentAsync()
        {
            System.Console.WriteLine("[UnityProjectArchitect][AI DEBUG] ConceptualSystemArchitectureGenerator: Starting content generation");
            try
            {
                // Get properly configured AI assistant
                IAIAssistant aiAssistant = _injectedAIAssistant;
                if (aiAssistant == null)
                {
                    #if UNITY_EDITOR
                    // Use Unity bridge's configured AI assistant
                    System.Console.WriteLine("[UnityProjectArchitect][AI DEBUG] Getting AI assistant from UnityServiceBridge");
                    aiAssistant = UnityProjectArchitect.Unity.UnityServiceBridge.GetAIAssistant();
                    #else
                    // For non-Unity builds, create a default AI assistant
                    System.Console.WriteLine("[UnityProjectArchitect][AI DEBUG] Creating default AI assistant");
                    aiAssistant = new UnityProjectArchitect.AI.Services.AIAssistant();
                    #endif
                }
                else
                {
                    System.Console.WriteLine("[UnityProjectArchitect][AI DEBUG] Using injected AI assistant");
                }

                System.Console.WriteLine($"[UnityProjectArchitect][AI DEBUG] AI assistant check: aiAssistant null={aiAssistant == null}, IsConfigured={aiAssistant?.IsConfigured}");
                
                if (aiAssistant?.IsConfigured == true)
                {
                    System.Console.WriteLine("[UnityProjectArchitect][AI DEBUG] AI assistant is configured. Building request...");
                    UnityProjectArchitect.Core.AIRequest request = new UnityProjectArchitect.Core.AIRequest
                    {
                        RequestType = UnityProjectArchitect.Core.AIRequestType.Generation,
                        Prompt = BuildSystemArchitecturePrompt(),
                        SectionType = sectionType,
                        ProjectContext = new UnityProjectArchitect.Core.ProjectData 
                        { 
                            ProjectName = gameConcept?.Title ?? "Concept Game",
                            ProjectDescription = gameDescription ?? "Game concept"
                        },
                        Configuration = aiAssistant.GetDefaultConfiguration(UnityProjectArchitect.Core.AIProvider.Claude)
                    };
                    
                    // Debug the configuration
                    System.Console.WriteLine($"[UnityProjectArchitect][AI DEBUG] Configuration details: ApiKey present={!string.IsNullOrEmpty(request.Configuration.ApiKey)}, IsValid={request.Configuration.IsValid()}, Provider={request.Configuration.Provider}, Model={request.Configuration.Model}");
                    
                    if (request.Parameters == null)
                        request.Parameters = new Dictionary<string, object>();
                    request.Parameters["GameDescription"] = gameDescription;
                    System.Console.WriteLine($"[UnityProjectArchitect][AI DEBUG] Sending AI request: Prompt length={request.Prompt.Length}, SectionType={request.SectionType}, Config={request.Configuration.Provider}, MaxTokens={request.Configuration.MaxTokens}, Temp={request.Configuration.Temperature}");
                    
                    var result = await aiAssistant.GenerateContentAsync(request);
                    if (result.Success && !string.IsNullOrEmpty(result.Content))
                    {
                        System.Console.WriteLine($"[UnityProjectArchitect][AI DEBUG] AI generation success: Content length={result.Content.Length} | Provider={result.Provider} | Time={result.ProcessingTime.TotalSeconds:F2}s");
                        StringBuilder aiContent = new StringBuilder();
                        aiContent.AppendLine("<!-- Generated by ConceptualSystemArchitectureGenerator using Claude AI -->");
                        aiContent.AppendLine($"*Generated on {System.DateTime.Now:yyyy-MM-dd HH:mm:ss} UTC using Claude AI API*");
                        aiContent.AppendLine();
                        aiContent.AppendLine(result.Content);
                        aiContent.AppendLine();
                        aiContent.AppendLine("---");
                        aiContent.AppendLine("**Generation Metadata:**");
                        aiContent.AppendLine("- Generated by: ConceptualSystemArchitectureGenerator with Claude AI");
                        aiContent.AppendLine($"- AI Provider: {result.Provider}");
                        aiContent.AppendLine($"- Processing Time: {result.ProcessingTime.TotalSeconds:F2} seconds");
                        aiContent.AppendLine($"- Generation Date: {System.DateTime.Now:yyyy-MM-dd HH:mm:ss}");
                        aiContent.AppendLine("---");
                        aiContent.AppendLine("<!-- End ConceptualSystemArchitectureGenerator -->");
                        return aiContent.ToString();
                    }
                    else
                    {
                        System.Console.WriteLine($"[UnityProjectArchitect][AI DEBUG] AI generation failed or returned empty. Success={result.Success}, Error={result.ErrorMessage}");
                    }
                }
                else
                {
                    System.Console.WriteLine("[UnityProjectArchitect][AI DEBUG] AI assistant is not configured. Falling back to offline mode.");
                }
            }
            catch (Exception ex)
            {
                System.Console.WriteLine($"[UnityProjectArchitect][AI DEBUG] Exception during AI generation: {ex}");
            }
            
            System.Console.WriteLine("[UnityProjectArchitect][AI DEBUG] Using offline fallback for ConceptualSystemArchitectureGenerator");
            // Fallback to offline generation
            StringBuilder content = new StringBuilder();

            // Add header and metadata (indicating offline generation)
            content.AppendLine("<!-- Generated by ConceptualSystemArchitectureGenerator (Offline Mode) -->");
            content.Append(GetSectionHeader("System Architecture"));
            content.AppendLine();
            content.Append(AddTimestamp());

            // Architecture Overview
            content.Append(GenerateArchitectureOverview());

            // System Components
            content.Append(GenerateSystemComponents());

            // Core Architecture Patterns
            content.Append(GenerateArchitecturePatterns());

            // Data Flow Architecture
            content.Append(GenerateDataFlowArchitecture());

            // Unity-Specific Architecture
            content.Append(GenerateUnityArchitecture());

            // Scalability Considerations
            content.Append(GenerateScalabilityConsiderations());

            // Add generation metadata
            content.Append(AddGenerationMetadata());
            content.AppendLine("<!-- End ConceptualSystemArchitectureGenerator -->");

            return await Task.FromResult(content.ToString());
        }

        private string BuildSystemArchitecturePrompt()
        {
            return $@"Generate comprehensive System Architecture documentation for a game concept.

Based on the game description provided, create detailed system architecture documentation that includes:

1. **Architecture Overview**: High-level system design and architectural principles
2. **Core System Components**: Key systems and modules (GameManager, Player Controller, UI, Audio, etc.)
3. **Architecture Patterns**: Design patterns used (MVC, Observer, State Machine, Object Pooling, etc.)
4. **Data Flow**: How data moves through the system and between components
5. **Unity-Specific Architecture**: Unity-specific systems (MonoBehaviour lifecycle, ScriptableObjects, Addressables, etc.)
6. **Scalability Considerations**: How the architecture supports growth and modifications
7. **Integration Points**: How systems interact and communicate
8. **Performance Considerations**: Architecture decisions that impact performance

Use the actual game concept provided in the context. Format the output as professional markdown with clear headers, diagrams (using Mermaid syntax where appropriate), and technical details suitable for developers.

Focus on creating a practical architecture that supports the specific gameplay features and technical requirements of this game concept.";
        }

        private string GenerateArchitectureOverview()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(GetSectionHeader("Architecture Overview", 2));

            sb.AppendLine($"The **{gameConcept.Title}** system architecture is designed around Unity's component-based ");
            sb.AppendLine($"architecture, optimized for {gameConcept.GameGenre.ToString().ToLower()} gameplay and ");
            sb.AppendLine($"{gameConcept.GameType.ToString().Replace("Game", "").ToLower()} platform requirements.");
            sb.AppendLine();

            sb.AppendLine("**Core Architectural Principles:**");
            List<string> principles = GenerateArchitecturalPrinciples();
            sb.Append(FormatList(principles));

            sb.AppendLine("**System Architecture Diagram:**");
            sb.AppendLine("```mermaid");
            sb.AppendLine("graph TD");
            sb.AppendLine("    A[Game Manager] --> B[Scene Manager]");
            sb.AppendLine("    A --> C[Player Controller]");
            sb.AppendLine("    A --> D[UI Manager]");
            sb.AppendLine("    A --> E[Audio Manager]");
            sb.AppendLine("    A --> F[Input Manager]");
            sb.AppendLine("    C --> G[Game State]");
            sb.AppendLine("    D --> H[Menu System]");
            sb.AppendLine("    E --> I[Sound Effects]");
            sb.AppendLine("    E --> J[Background Music]");
            sb.AppendLine("```");
            sb.AppendLine();

            return sb.ToString();
        }

        private string GenerateSystemComponents()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(GetSectionHeader("Core System Components", 2));

            Dictionary<string, SystemComponent> components = GenerateCoreComponents();

            foreach (KeyValuePair<string, SystemComponent> component in components)
            {
                sb.Append(GetSectionHeader(component.Key, 3));
                sb.AppendLine($"**Purpose:** {component.Value.Purpose}");
                sb.AppendLine();
                sb.AppendLine("**Responsibilities:**");
                sb.Append(FormatList(component.Value.Responsibilities));
                sb.AppendLine("**Key Methods:**");
                sb.Append(FormatList(component.Value.KeyMethods));
                if (component.Value.Dependencies.Any())
                {
                    sb.AppendLine("**Dependencies:**");
                    sb.Append(FormatList(component.Value.Dependencies));
                }
                sb.AppendLine();
            }

            return sb.ToString();
        }

        private string GenerateArchitecturePatterns()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(GetSectionHeader("Architecture Patterns", 2));

            Dictionary<string, PatternImplementation> patterns = GenerateDesignPatterns();

            foreach (KeyValuePair<string, PatternImplementation> pattern in patterns)
            {
                sb.Append(GetSectionHeader(pattern.Key, 3));
                sb.AppendLine($"**Use Case:** {pattern.Value.UseCase}");
                sb.AppendLine($"**Implementation:** {pattern.Value.Implementation}");
                sb.AppendLine();
                if (pattern.Value.Benefits.Any())
                {
                    sb.AppendLine("**Benefits:**");
                    sb.Append(FormatList(pattern.Value.Benefits));
                }
                sb.AppendLine();
            }

            return sb.ToString();
        }

        private string GenerateDataFlowArchitecture()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(GetSectionHeader("Data Flow Architecture", 2));

            sb.AppendLine("**Data Flow Diagram:**");
            sb.AppendLine("```mermaid");
            sb.AppendLine("flowchart LR");
            sb.AppendLine("    Input[User Input] --> Controller[Input Controller]");
            sb.AppendLine("    Controller --> Game[Game Logic]");
            sb.AppendLine("    Game --> State[Game State]");
            sb.AppendLine("    State --> UI[UI Updates]");
            sb.AppendLine("    State --> Audio[Audio Events]");
            sb.AppendLine("    State --> Save[Save System]");
            sb.AppendLine("    Save --> Persistence[Data Persistence]");
            sb.AppendLine("```");
            sb.AppendLine();

            List<DataFlowComponent> dataFlows = GenerateDataFlowComponents();
            foreach (DataFlowComponent flow in dataFlows)
            {
                sb.Append(GetSectionHeader(flow.Name, 3));
                sb.AppendLine($"**Data Type:** {flow.DataType}");
                sb.AppendLine($"**Flow Direction:** {flow.FlowDirection}");
                sb.AppendLine($"**Processing:** {flow.Processing}");
                sb.AppendLine();
            }

            return sb.ToString();
        }

        private string GenerateUnityArchitecture()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(GetSectionHeader("Unity-Specific Architecture", 2));

            sb.AppendLine("**Unity Integration Points:**");
            List<string> unityFeatures = GenerateUnityIntegrationPoints();
            sb.Append(FormatList(unityFeatures));

            sb.AppendLine("**MonoBehaviour Lifecycle:**");
            sb.AppendLine("```mermaid");
            sb.AppendLine("sequenceDiagram");
            sb.AppendLine("    participant Unity");
            sb.AppendLine("    participant GameManager");
            sb.AppendLine("    participant PlayerController");
            sb.AppendLine("    Unity->>GameManager: Awake()");
            sb.AppendLine("    Unity->>PlayerController: Awake()");
            sb.AppendLine("    Unity->>GameManager: Start()");
            sb.AppendLine("    Unity->>PlayerController: Start()");
            sb.AppendLine("    loop Game Loop");
            sb.AppendLine("        Unity->>PlayerController: Update()");
            sb.AppendLine("        Unity->>GameManager: Update()");
            sb.AppendLine("    end");
            sb.AppendLine("```");
            sb.AppendLine();

            Dictionary<string, string> unityComponents = GenerateUnityComponentUsage();
            sb.Append(FormatTable(unityComponents, "Unity Feature", "Usage"));

            return sb.ToString();
        }

        private string GenerateScalabilityConsiderations()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(GetSectionHeader("Scalability Considerations", 2));

            sb.AppendLine("**Modular Design:**");
            List<string> modularFeatures = GenerateModularDesignFeatures();
            sb.Append(FormatList(modularFeatures));

            sb.AppendLine("**Performance Optimization:**");
            List<string> optimizations = GeneratePerformanceOptimizations();
            sb.Append(FormatList(optimizations));

            sb.AppendLine("**Future Expansion Points:**");
            List<string> expansionPoints = GenerateFutureExpansionPoints();
            sb.Append(FormatList(expansionPoints));

            return sb.ToString();
        }

        private List<string> GenerateArchitecturalPrinciples()
        {
            return new List<string>
            {
                "**Separation of Concerns:** Each system handles a specific aspect of the game",
                "**Loose Coupling:** Systems communicate through events and interfaces",
                "**Single Responsibility:** Each component has a clear, focused purpose",
                "**Dependency Injection:** Dependencies are provided rather than created",
                "**Event-Driven Architecture:** Systems respond to events rather than direct calls",
                "**Data-Oriented Design:** Performance-critical systems use efficient data structures"
            };
        }

        private Dictionary<string, SystemComponent> GenerateCoreComponents()
        {
            Dictionary<string, SystemComponent> components = new Dictionary<string, SystemComponent>
            {
                ["Game Manager"] = new SystemComponent
                {
                    Purpose = "Central controller that manages overall game state and coordinates other systems",
                    Responsibilities = new List<string>
                    {
                        "Initialize and configure game systems",
                        "Manage game state transitions",
                        "Coordinate system interactions",
                        "Handle application lifecycle events"
                    },
                    KeyMethods = new List<string>
                    {
                        "InitializeGame()",
                        "StartGame()",
                        "PauseGame()",
                        "EndGame()",
                        "OnApplicationPause()"
                    },
                    Dependencies = new List<string> { "Scene Manager", "UI Manager", "Audio Manager" }
                },
                ["Player Controller"] = new SystemComponent
                {
                    Purpose = "Handles player input and character movement/actions",
                    Responsibilities = new List<string>
                    {
                        "Process user input",
                        "Execute player actions",
                        "Manage character state",
                        "Handle collision detection"
                    },
                    KeyMethods = new List<string>
                    {
                        "HandleInput()",
                        "Move(Vector2)",
                        "PerformAction()",
                        "OnCollisionEnter()"
                    },
                    Dependencies = new List<string> { "Input Manager", "Physics System", "Animation Controller" }
                }
            };

            // Add game-specific components based on genre
            switch (gameConcept.GameGenre)
            {
                case GameGenre.RPG:
                    components["Character System"] = new SystemComponent
                    {
                        Purpose = "Manages character stats, progression, and RPG mechanics",
                        Responsibilities = new List<string>
                        {
                            "Track character statistics",
                            "Handle experience and leveling",
                            "Manage skill trees",
                            "Process equipment changes"
                        },
                        KeyMethods = new List<string> { "GainExperience()", "LevelUp()", "EquipItem()", "LearnSkill()" },
                        Dependencies = new List<string> { "Save System", "UI Manager" }
                    };
                    break;

                case GameGenre.Action:
                    components["Combat System"] = new SystemComponent
                    {
                        Purpose = "Manages combat mechanics, damage calculation, and enemy interactions",
                        Responsibilities = new List<string>
                        {
                            "Process combat actions",
                            "Calculate damage",
                            "Manage health and status effects",
                            "Handle enemy AI behavior"
                        },
                        KeyMethods = new List<string> { "DealDamage()", "ApplyEffect()", "ProcessCombat()" },
                        Dependencies = new List<string> { "Player Controller", "AI Manager" }
                    };
                    break;
            }

            return components;
        }

        private Dictionary<string, PatternImplementation> GenerateDesignPatterns()
        {
            return new Dictionary<string, PatternImplementation>
            {
                ["Singleton Pattern"] = new PatternImplementation
                {
                    UseCase = "Game Manager and other single-instance systems",
                    Implementation = "Ensures only one instance exists throughout the game lifecycle",
                    Benefits = new List<string>
                    {
                        "Global access point",
                        "Resource management",
                        "Consistent state"
                    }
                },
                ["Observer Pattern"] = new PatternImplementation
                {
                    UseCase = "Event system for decoupled communication between systems",
                    Implementation = "Systems subscribe to events and react when they are triggered",
                    Benefits = new List<string>
                    {
                        "Loose coupling between systems",
                        "Easy to add new listeners",
                        "Centralized event management"
                    }
                },
                ["State Machine"] = new PatternImplementation
                {
                    UseCase = "Managing game states and character behavior",
                    Implementation = "Clear state definitions with defined transitions",
                    Benefits = new List<string>
                    {
                        "Clear behavior definitions",
                        "Predictable state transitions",
                        "Easy debugging and maintenance"
                    }
                },
                ["Object Pooling"] = new PatternImplementation
                {
                    UseCase = "Managing frequently created/destroyed objects",
                    Implementation = "Pre-allocate objects and reuse them to avoid garbage collection",
                    Benefits = new List<string>
                    {
                        "Improved performance",
                        "Reduced garbage collection",
                        "Consistent frame rates"
                    }
                }
            };
        }

        private List<DataFlowComponent> GenerateDataFlowComponents()
        {
            return new List<DataFlowComponent>
            {
                new DataFlowComponent
                {
                    Name = "Input Processing",
                    DataType = "Input Events",
                    FlowDirection = "Input → Controller → Game Logic",
                    Processing = "Raw input is processed into game commands"
                },
                new DataFlowComponent
                {
                    Name = "Game State Updates",
                    DataType = "State Changes",
                    FlowDirection = "Game Logic → State Manager → UI/Audio",
                    Processing = "Game state changes trigger UI updates and audio events"
                },
                new DataFlowComponent
                {
                    Name = "Save Data",
                    DataType = "Persistent Data",
                    FlowDirection = "Game State → Save System → Storage",
                    Processing = "Game progress is serialized and saved to persistent storage"
                }
            };
        }

        private List<string> GenerateUnityIntegrationPoints()
        {
            List<string> features = new List<string>
            {
                "**MonoBehaviour Lifecycle:** Awake, Start, Update, FixedUpdate for system initialization and updates",
                "**Scene Management:** Unity's SceneManager for level transitions and loading",
                "**Input System:** New Unity Input System for cross-platform input handling",
                "**UI Toolkit:** Modern UI system for responsive and scalable interfaces"
            };

            if (gameConcept.GameType == ProjectType.Game3D)
            {
                features.Add("**Cinemachine:** Advanced camera controls and smooth transitions");
                features.Add("**Timeline:** Cutscenes and scripted sequences");
            }

            if (gameConcept.TechnicalFeatures.Any(f => f.Contains("Multiplayer")))
            {
                features.Add("**Netcode for GameObjects:** Unity's official networking solution");
            }

            return features;
        }

        private Dictionary<string, string> GenerateUnityComponentUsage()
        {
            Dictionary<string, string> components = new Dictionary<string, string>
            {
                ["ScriptableObjects"] = "Configuration data, game settings, and asset references",
                ["Addressables"] = "Efficient asset loading and memory management",
                ["Unity Events"] = "Inspector-configurable event connections",
                ["Coroutines"] = "Async operations and timed sequences"
            };

            if (gameConcept.GameType == ProjectType.Game3D)
            {
                components["Physics"] = "Rigidbody and Collider components for realistic movement";
                components["Animation"] = "Animator controllers for character and object animations";
            }

            return components;
        }

        private List<string> GenerateModularDesignFeatures()
        {
            return new List<string>
            {
                "**Plugin Architecture:** Easy addition of new gameplay features",
                "**Configuration-Driven:** Settings and parameters adjustable without code changes",
                "**Asset Bundling:** Content can be loaded dynamically or post-launch",
                "**Interface-Based Design:** Systems communicate through well-defined interfaces"
            };
        }

        private List<string> GeneratePerformanceOptimizations()
        {
            List<string> optimizations = new List<string>
            {
                "**Object Pooling:** Reuse objects to minimize garbage collection",
                "**LOD Systems:** Level-of-detail for complex objects and scenes",
                "**Efficient Data Structures:** Arrays and structs for performance-critical code",
                "**Batching:** Combine rendering calls to reduce draw calls"
            };

            if (gameConcept.GameType == ProjectType.Mobile)
            {
                optimizations.Add("**Mobile Optimization:** Texture compression and reduced poly counts");
                optimizations.Add("**Battery Optimization:** Efficient update loops and reduced background processing");
            }

            return optimizations;
        }

        private List<string> GenerateFutureExpansionPoints()
        {
            return new List<string>
            {
                "**Modding Support:** Plugin architecture allows community modifications",
                "**Content Pipeline:** Tools for easy content creation and import",
                "**Analytics Integration:** Built-in support for player behavior tracking",
                "**Localization Framework:** Multi-language support infrastructure",
                "**Cloud Save Integration:** Player progress synchronization across devices",
                "**Social Features:** Friend systems and shared content capabilities"
            };
        }
    }

    public class SystemComponent
    {
        public string Purpose { get; set; } = "";
        public List<string> Responsibilities { get; set; } = new List<string>();
        public List<string> KeyMethods { get; set; } = new List<string>();
        public List<string> Dependencies { get; set; } = new List<string>();
    }

    public class PatternImplementation
    {
        public string UseCase { get; set; } = "";
        public string Implementation { get; set; } = "";
        public List<string> Benefits { get; set; } = new List<string>();
    }

    public class DataFlowComponent
    {
        public string Name { get; set; } = "";
        public string DataType { get; set; } = "";
        public string FlowDirection { get; set; } = "";
        public string Processing { get; set; } = "";
    }
}